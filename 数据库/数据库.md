### 数据库三级模式
数据库领域的标准结构是三级模式结构，包括外模式（用户级）、模式（概念级）和内模式（物理级）。
- 外模式又称子模式或用户模式。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用数据操纵语言(Data Manipulation Language，DML)对这些数据记录进行操作。
- 模式是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据模式描述语言(Data Description Language，DDL)来描述、定义的。概念模式反映了数据库系统的整体观。
- 内模式又称存储模式，对应于物理级。它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义的。内模式反映了数据库系统的存储观。



### 数据库三范式
1. 第一范式：数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。
2. 第二范式：实体的属性完全依赖于主关键字。所谓完全依赖是指不存在仅依赖于主关键字一部分的属性。
3. 第三范式：属性不依赖于其他非主属性。每一个字段都和主键直接相关而不能间接相关。

### 事务特性ACID
1. 原子性（Atomicity）指事务作为整体来执行，要么全部执行，要么全不执行。
2. 一致性（Consistency）指事务应确保数据从一个一致的状态转变为另一个一致的状态。
3. 隔离性（Isolation）指多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
4. 持久性（Durability）指已提交的事务修改数据会被持久保存。

### 隔离级别
1. 读未提交
这种事务隔离级别下，select语句不加锁。
此时，可能读取到不一致的数据，即“脏读”。这是并发最高，一致性最差的隔离级别。
2. 读已提交
可避免脏读。
在互联网大数据量，高并发量的场景下，几乎不会使用上述两种隔离级别。
3. 可重复读
mysql默认隔离级别
可避免脏读、不可重复读的发生
4. 串行化
可避免脏读、不可重复读、幻读的发生。

隔离级别最高的是Serializable级别，级别越高，执行效率越低。串行化这种级别就是以锁表的形式使其他线程在锁外等待。

查询和设置数据库的隔离级别。
```sql
set tx_isolation='隔离级别';    --read-uncommitted    read-committed    repeatable-read    serializable
set tx_isolation='read-uncommitted';
select @@tx_isolation;
```
不考虑隔离性导致问题：
1. 脏读
脏读是指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。
```sql
--事务1
START TRANSACTION；
updata t_table set name = 'wangwu' where id = 1;    --此时事务2查询id = 1
ROLLBACK；
 
--事务2
select * from t_table where id = 1;        --查询到 id = 1， name = 'wangwu'
```
2. 不可重复读
不可重复读是指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。
```sql
--事务1
select * from t_table where id = 1;    -- 查询到 id = 1, name = list, 事务2在此时提交
select * from t_table where id = 1;    -- 查询到 id = 1, name = wangwu
 
--事务2
start transaction;
update t_table set name = 'wangwu' where id = 1;
COMMIT;
```
3. 幻读
幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。
```sql
--事务1
select * from t_table where id = 2;    --返回NULL,此时事务2提交
select * from t_table where id = 2;    --返回id = 2, name = wangwu
 
--事务2
insert into t_table values(2,'wangwu');
COMMIT;
```

### 索引

索引是一个排序的列表，列表中存着索引值和包含这个值的数据所在行的物理表。使用索引后不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。

索引是一张表，该表保存了主键与索引字段，并指向实体表的记录。索引虽然会大大提高查询速度，同时会降低更新表的速度。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。

建立索引会占用磁盘空间的索引文件。创建索引会对表加锁，因此实际操作中需要在业务空闲期间进行。

#### 索引的优缺点

优点：

- 大大加快数据的检索速度，这也是创建索引的最主要的原因；
- 加速表和表之间的连接；
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；

缺点：

- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；
- 空间方面：索引需要占物理空间。

#### 索引的使用策略

**什么时候使用索引：**

- 主键自动建立唯一索引
- 经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引；
- 作为排序的列要建立索引；
- 查询中与其他表关联的字段，外键关系建立索引
- 高并发条件下倾向组合索引；
- 用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引

**什么时候不要使用索引：**

- 经常增删改的列不要建立索引；
- 有大量重复的列不建立索引；
- 表记录太少不要建立索引。一般数据表中记录超过1000条，可以考虑使用索引。

**索引失效的情况：**

//自己再查证一下

- 组合索引中不能有列的值为null，如果有则失效。
- 在一个查询语句中索引只能使用一次，where中使用了，在order by中就不要用了。
- LIKE操作，'%test%'不会使用索引，即索引失效。但'test%'可以使用索引
- 在索引的列上使用表达式或者函数会使索引失效，例如：select * from users where YEAR(adddate)<2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select * from users where adddate<’2007-01-01′。其它通配符同样，也就是说，在查询条件中使用正则表达式时，只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。
- 在查询条件中使用不等于，包括<符号、>符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用<符号或者>符号不会使索引失效。
- 在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。
- 字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效。
- 在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来。
- 尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引；

#### 索引的优化

- 最左前缀
  索引的最左前缀和和B+Tree中的“最左前缀原理”有关，举例来说就是如果设置了组合索引<col1,col2,col3>那么以下3中情况可以使用索引：col1，<col1,col2>，<col1,col2,col3>，其它的列，比如<col2,col3>，<col1,col3>，col2，col3等等都是不能使用索引的。

  根据最左前缀原则，我们一般把排序分组频率最高的列放在最左边，以此类推。

- 使用短索引
  对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。